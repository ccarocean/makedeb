#!/bin/bash

# makedeb - build Debain packages from PKGBUILD files
# Copyright (C) 2018 Michael R. Shannon <mrshannon.aerospace@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.



# used for passing function outputs around
declare retval
declare missing_depends=()
declare installed_depends=()
declare source_files=()


declare pkgname=""
declare pkgver=""
declare pkgrel=""
declare depends=()
declare makedepends=()
declare checkdepends=()
declare source=()
declare sources=()
declare noextract=()
declare section=""
declare priority="optional"
declare essential="no"
declare maintainer=""
declare pkgdesc=""
declare pkglong=""
declare url=""
declare predepends=()
declare suggests=()
declare enhances=()
declare replaces=()
declare conflicts=()
declare provides=()
declare arch=""


# GLOBALS

# ansi codes
declare -r ANSI_RESET='\033[0m'
declare -r ANSI_BOLD='\033[1m'
declare -r ANSI_RED='\033[0;31m'
declare -r ANSI_GREEN='\033[0;32m'
declare -r ANSI_YELLOW='\033[0;33m'
declare -r ANSI_BLUE='\033[0;34m'

declare -r EXIT_ON_FAIL=1



# OPTIONS
INSTALL_DEPENDS=0
REMOVE_DEPENDS=0




# FUNCTIONS

print1() {
    echo -e "${ANSI_GREEN}${ANSI_BOLD}==>${ANSI_RESET}${ANSI_BOLD} ${1}${ANSI_RESET}"
}


print2() {
    echo -e "  ${ANSI_BLUE}${ANSI_BOLD}->${ANSI_RESET}${ANSI_BOLD} ${1}${ANSI_RESET}"
}


print3() {
    echo "      $1"
}


warn() {
    echo -e "${ANSI_YELLOW}${ANSI_BOLD}==> WARNING:${ANSI_RESET}${ANSI_BOLD} ${1}${ANSI_RESET}"
}


error() {
    echo -e "${ANSI_RED}${ANSI_BOLD}==> ERROR:${ANSI_RESET}${ANSI_BOLD} ${1}${ANSI_RESET}"
    if [[ "$EXIT_ON_FAIL" -ne 0 ]]; then
        exit 1
    fi
}


# https://stackoverflow.com/a/17841619
join() {
    local d=$1
    shift
    echo -n "$1"
    shift
    printf "%s" "${@/#/$d}"
}


strip() {
    sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}


date_string() {
    date -u '+%a %d %b %Y %r UTC'
    # date -u '+%F %T UTC'
}


ctrl_c() {
    echo -e "\nExiting..."
    exit 1
}


# https://stackoverflow.com/a/24067243
version_gt() {
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}


version_compare() {
    local first=$1
    local op=$2
    local second=$3
    
    case "$op" in
        "<")
            version_gt "$second" "$first"
            ;;
        "<=")
            test "$first" == "$second" || version_gt "$second" "$first"
            ;;
        "==")
            test "$first" == "$second"
            ;;
        ">=")
            test "$first" == "$second" || version_gt "$first" "$second"
            ;;
        ">")
            version_gt "$first" "$second"
            ;;
        *)
            error "Invalid operator $op"
            exit 1
            ;;
    esac
    return $?
}


# reads the maintainer from the comment at the top of the PKGBUILD file, this
# is here for compatibility with Arch Linux makepkg, you should explicitly set
# the maintainer field in PKGBUILD for makedeb
read_maintainer() {
    maintainer=$(grep -Po '(?<=Maintainer:).*$' PKGBUILD)
    maintainer=$(echo "$maintainer" | strip)
}


print_start_message() {
    print1 "Making package: ${pkgname} ${pkgver}-${pkgrel} ($(date_string))"
}


# validates entries in the sourced PKGBUILD file, which must be sourced before
# calling this function.
validate_pkgbuild() {
    local tmp=()
    # combine source and sources and save them back
    tmp=("${source[@]}" "${sources[@]}")
    source=("${tmp[@]}")
    sources=("${tmp[@]}")
    # combine optdepends and recommends and save them back
    tmp=("${optdepends[@]}" "${recommends[@]}")
    optdepends=("${tmp[@]}")
    recommends=("${tmp[@]}")
}


check_depends() {
    local package
    local packages
    local name
    local op
    local required_version
    local installed_version
    local found
    retval=()
    for package_string in "$@"; do
        # convert an alternative list with | into an array
        IFS='|' read -r -a packages <<< "${package_string}"
        found=""
        for package in "${packages[@]}"; do
            name=$(echo "$package" | strip | grep -o '^[^<=>]*')
            op=$(echo "$package" | strip | grep -Po "(?<=^$name)"'[<=>]*')
            required_version=$(echo "$package" | strip | \
                grep -Po "(?<=^$name$op)"'[0-9\.]*')
            installed_version=$(dpkg -s "${name}" 2>/dev/null | \
                grep -Po '(?<=Version: )[0-9\.]*')
            if [[ -n "$installed_version" ]]; then
                if [[ -n "$required_version" ]]; then
                    if ! version_compare "$installed_version" "$op" \
                            "$required_version"; then
                        local msg
                        msg="${name}'s installed version "
                        msg="${msg}(${installed_version}) is not ${op} "
                        msg="${msg}${required_version}"
                        error "$msg"
                    fi
                fi
                print2 "Found ${name}"
                found=1
            fi
        done
        if [[ -z "$found" ]]; then
            retval+=("${package_string}")
        fi
    done
}


check_runtime_depends() {
    if [[ ${#depends[@]} -gt 0 ]]; then
        print1 "Checking runtime dependencies..."
        check_depends "${depends[@]}"
        missing_depends+=("${retval[@]}")
    fi
}


check_buildtime_depends() {
    if [[ ${#makedepends[@]} -gt 0 ]]; then
        print1 "Checking buildtime dependencies..."
        check_depends "${makedepends[@]}"
        missing_depends+=("${retval[@]}")
    fi
}


check_checktime_depends() {
    if [[ ${#checkdepends[@]} -gt 0 ]]; then
        print1 "Checking checktime dependencies..."
        check_depends "${checkdepends[@]}"
        missing_depends+=("${retval[@]}")
    fi
}


install_missing_depends() {
    local packages
    local name
    if [[ $(( ${#missing_depends[@]})) -gt 0 ]]; then
        print1 "Missing dependencies:"
        for package in "${missing_depends[@]}"; do
            print2 "$package"
        done
        if [[ -z "$INSTALL_DEPENDS" ]]; then
            local msg
            msg="Would you like to install the required dependencies? (y/N): "
            read -p "$msg" -n 1 -r
            echo ""
            if [[ "$REPLY" == "y" || "$REPLY" == "Y" ]]; then
                INSTALL_DEPENDS=1
            fi
        fi
        if [[ "$INSTALL_DEPENDS" -ne 0 ]]; then
            print1 "Installing dependencies..."
            sudo -k
            for package in "${missing_depends[@]}"; do
                packages=(${package//|/})
                name=$(echo "${packages[0]}" | grep -o '^[^<=>]*')
                print2 "${name}"
                if sudo apt-get install --yes "${name}"; then
                    sudo apt-mark auto "${name}"
                    installed_depends+=("${name}")
                else
                    error "Failed to install ${name}."
                fi
            done
        else
            error "Could not resolve all dependencies."
        fi
    fi
}


retrieve_sources() {
    print1 "Retrieving sources..."
    local source_file
    local name
    local url
    # loop through each source file
    for source_file in "${sources[@]}"; do
        url=$(echo "$source_file" | awk -F'::' '{print $2}')
        name=$(echo "$source_file" | awk -F'::' '{print $1}')
        if [[ "$(basename "$name")" != "$name" ]]; then
            url=$name
            name=$(basename "$name")
        fi
        # check if file is already downloaded
        if [[ -f "${startdir}/${name}" ]]; then
            print2 "Found ${name}"
        elif [[ -n "${name}" && -n "${url}" ]]; then
            print2 "Downloading ${name}"
            if ! curl --location --output "${startdir}/${name}" "$url"; then
                error "Failed to download '${name}' from ${url}"
            fi
        else
            error "File ${name} does not exist."
        fi
        source_files+=("$name")
    done
}


validate_sources() {
    local failed=0
    if ! _validate_sources md5sum; then
        failed=1
    fi
    if ! _validate_sources sha1sum; then
        failed=1
    fi
    if ! _validate_sources sha256sum; then
        failed=1
    fi
    if ! _validate_sources sha384sum; then
        failed=1
    fi
    if ! _validate_sources sha512; then
        failed=1
    fi
    if [[ $failed -gt 0 ]]; then
        error "One or more files did not pass the validity check!"
    fi
}


_validate_sources() {
    local -n sums="${1}s"
    if [[ ${#sums[@]} -gt 0 ]]; then
        print1 "Validating source files with ${1}s..."
        if [[ ${#sums[@]} -ne ${#source_files[@]} ]]; then
            error "'${1}s' array not the same length as the 'source' array."
        fi
        local sum
        local failed=0
        for ((i=0;i<${#source_files[@]};++i)); do
            if [[ ${sums[i]^^} != "SKIP" ]]; then
                echo -en "  ${ANSI_BLUE}${ANSI_BOLD}->${ANSI_RESET} "
                echo -en "${ANSI_BOLD}${source_files[i]} ... ${ANSI_RESET}"
                sum=$(${1} "${startdir}/${source_files[i]}" | cut -d' ' -f1)
                if [[ "$sum" == "${sums[i]}" ]]; then
                    echo -e "${ANSI_BOLD}Passed${ANSI_RESET}"
                else
                    echo -e "${ANSI_RED}${ANSI_BOLD}FAILED${ANSI_RESET}"
                    failed=1
                fi
            fi
        done
        return $failed
    fi
}


extract_sources() {
    mkdir -p "${srcdir}"
    print1 "Extracting sources"
    for file in "${source_files[@]}"; do
        local extract=1
        for exception in "${noextract[@]}"; do
            if [[ $(basename "$exception") == "$(basename "$file")" ]]; then
                extract=0
            fi
        done
        if [[ $extract -gt 0 ]]; then
            case ${file,,} in
                *.tar|*.zip|*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.7z)
                    print2 "Extracting ${file} with bsdtar"
                    if ! bsdtar -C "${srcdir}" -xf "${startdir}/${file}"; then
                        error "Failed to extract $file"
                    fi
                    ;;
                *)
                    extract=0
                    ;;
            esac
        fi
        if [[ $extract -eq 0 ]]; then
            cp "${startdir}/${file}" "${srcdir}/${file}"
        fi
    done
}


run_prepare() {
    if [[ "$(type -t prepare)" == "function" ]]; then
        print1 "Starting prepare()"
        prepare
    fi
}


run_build() {
    if [[ "$(type -t build)" == "function" ]]; then
        print1 "Starting build()"
        build
    fi
}


run_check() {
    if [[ "$(type -t check)" == "function" ]]; then
        print1 "Starting check()"
        check
    fi
}


run_package() {
    if [[ "$(type -t package)" != "function" ]]; then
        error "No package() function in PKGBUILD."
    fi
    mkdir -p "${pkgdir}"
    print1 "Starting package()"
    fakeroot bash <<EOF
declare startdir=${startdir}
declare srcdir=${srcdir}
declare pkgdir=${pkgdir}
. "${startdir}/PKGBUILD"
package
EOF
}


make_debian() {
    mkdir -p "${pkgdir}/DEBIAN"
    local control="${pkgdir}/DEBIAN/control"
    true >"${control}"

    # Package
    echo "Package: ${pkgname}" >>"${control}"

    # Version
    echo "Version: ${pkgver}" >>"${control}"

    # Section
    if [[ -n "${section}" ]]; then
        echo "Section: ${section}" >>"${control}"
    fi

    # Priority
    if [[ -n "${priority}" ]]; then
        echo "Priority: ${priority}" >>"${control}"
    fi

    # Architecture
    local debarch=""
    case "${arch}" in
        any)
            debarch=any
            ;;
        i686)
            debarch=i386
            ;;
        x86_64)
            debarch=amd64
            ;;
        *)
            debarch=$arch
    esac
    echo "Architecture: ${debarch}" >>"${control}"

    # Essential
    if [[ -n "${essential}" ]]; then
        echo "Essential: ${essential}" >>"${control}"
    fi

    # Depends
    if [[ ${#depends[@]} -gt 0 ]]; then
        echo "Depends: $(dependency_string "${depends[@]}")" >>"${control}"
    fi

    # Pre-Depends
    if [[ ${#predepends[@]} -gt 0 ]]; then
        echo "Pre-Depends: $(dependency_string "${predepends[@]}")" >>"${control}"
    fi

    # Recommends
    if [[ ${#recommends[@]} -gt 0 ]]; then
        echo "Recommends: $(dependency_string "${recommends[@]}")" >>"${control}"
    fi

    # Suggests
    if [[ ${#suggests[@]} -gt 0 ]]; then
        echo "Suggests: $(dependency_string "${suggests[@]}")" >>"${control}"
    fi

    # Enhances
    if [[ ${#enhances[@]} -gt 0 ]]; then
        echo "Enhances: $(dependency_string "${enhances[@]}")" >>"${control}"
    fi

    # Breaks and Replaces
    if [[ ${#replaces[@]} -gt 0 ]]; then
        echo "Breaks: $(dependency_string "${replaces[@]}")" >>"${control}"
        echo "Replaces: $(dependency_string "${replaces[@]}")" >>"${control}"
    fi

    # Conflicts
    if [[ ${#conflicts[@]} -gt 0 ]]; then
        echo "Conflicts: $(dependency_string "${conflicts[@]}")" >>"${control}"
    fi

    # Provides
    if [[ ${#provides[@]} -gt 0 ]]; then
        echo "Provides: $(dependency_string "${provides[@]}")" >>"${control}"
    fi

    # Installed-Size
    local size
    size=$(du -ks --apparent-size "${pkgdir}" | cut -f1)
    echo "Installed-Size: ${size}" >>"${control}"

    # Maintainer
    echo "Maintainer: ${maintainer}" >>"${control}"

    # Homepage
    if [[ -n "${url}" ]]; then
        echo "Homepage: ${url}" >>"${control}"
    fi

    # Description
    echo "Description: ${pkgdesc}" >>"${control}"
    echo "${pkglong}" | sed -e 's/^/ /g' >>"${control}"
}


dependency_string() {
    local name
    local op
    local version
    local packages
    local tmp
    local dependencies=()
    for package_string in "$@"; do
        # convert an alternative list with | into an array
        IFS='|' read -r -a packages <<< "${package_string}"
        tmp=()
        for package in "${packages[@]}"; do
            name=$(echo "$package" | strip | grep -o '^[^<=>]*')
            op=$(echo "$package" | strip | grep -Po "(?<=^$name)"'[<=>]*')
            version=$(echo "$package" | strip | \
                grep -Po "(?<=^$name$op)"'[0-9\.]*')
            if [[ -n ${version} ]]; then
                tmp+=("${name} (${op} ${version})")
            else
                tmp+=("${name}")
            fi
        done
        dependencies+=("$(join ' | ' "${tmp[@]}")")
    done
    join ', ' "${dependencies[@]}"
}


print_completion_message() {
    print1 "Finished making: ${pkgname} ${pkgver}-${pkgrel} ($(date_string))"
}


cleanup() {
    if [[ ${#installed_depends[@]} -gt 0 ]]; then
        if [[ -z "$REMOVE_DEPENDS" ]]; then
            local msg
            msg="Would you like to remove the build dependencies installed "
            msg="${msg} earlier? (y/N): "
            read -p "$msg" -n 1 -r
            echo ""
            if [[ "$REPLY" == "y" || "$REPLY" == "Y" ]]; then
                REMOVE_DEPENDS=1
            fi
        fi
        if [[ "$REMOVE_DEPENDS" -ne 0 ]]; then
            print1 "Removing dependencies installed earlier..."
            for package in "${installed_depends[@]}"; do
                print2 "${package}"
                if ! sudo apt-get purge --yes "${package}"; then
                    warn "Failed to remove ${package}."
                fi
            done
        fi
        installed_depends=()
    fi
}




# BEGIN SCRIPT

trap ctrl_c INT
trap cleanup EXIT




# source the build script
read_maintainer
. PKGBUILD
validate_pkgbuild

declare startdir="$PWD"
declare srcdir="${startdir}/src"
declare pkgdir="${startdir}/${pkgname}-${pkgver}-${pkgrel}"

print_start_message
# check_runtime_depends
check_buildtime_depends
check_checktime_depends
install_missing_depends
retrieve_sources
validate_sources
extract_sources
run_prepare
run_build
run_check
run_package
make_debian
# build_deb
cleanup
print_completion_message
